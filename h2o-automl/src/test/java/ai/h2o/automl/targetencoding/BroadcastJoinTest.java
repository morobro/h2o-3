package ai.h2o.automl.targetencoding;

import com.pholser.junit.quickcheck.Property;
import com.pholser.junit.quickcheck.generator.InRange;
import com.pholser.junit.quickcheck.runner.JUnitQuickcheck;
import org.junit.After;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import water.*;
import water.fvec.*;
import water.rapids.Merge;
import water.util.DistributedException;
import water.util.IcedHashMap;

import static org.junit.Assert.*;
import static ai.h2o.automl.targetencoding.BroadcastJoinForTargetEncoder.*;

@RunWith(JUnitQuickcheck.class)
public class BroadcastJoinTest extends TestUtil {

  @BeforeClass
  public static void setup() {
    stall_till_cloudsize(1);
  }

  private Frame fr = null;

  @Test
  public void joinPerformsWithoutLoosingOriginalOrderTest() {

    Frame rightFr = null;
    Vec emptyNumerator = null;
    Vec emptyDenominator = null;
    try {

      fr = new TestFrameBuilder()
              .withName("testFrame")
              .withColNames("ColA", "fold")
              .withVecTypes(Vec.T_CAT, Vec.T_NUM)
              .withDataForCol(0, ar("a", "c", "b"))
              .withDataForCol(1, ar(1, 0, 1))
              .build();

      rightFr = new TestFrameBuilder()
              .withName("testFrame2")
              .withColNames("ColA", "fold", TargetEncoder.NUMERATOR_COL_NAME, TargetEncoder.DENOMINATOR_COL_NAME)
              .withVecTypes(Vec.T_CAT, Vec.T_NUM, Vec.T_NUM, Vec.T_NUM)
              .withDataForCol(0, ar("a", "b", "c"))
              .withDataForCol(1, ar(1, 0, 0))
              .withDataForCol(2, ar(22, 33, 42))
              .withDataForCol(3, ar(44, 66, 84))
              .build();

      emptyNumerator = fr.anyVec().makeCon(0);
      fr.add(TargetEncoder.NUMERATOR_COL_NAME, emptyNumerator);
      emptyDenominator = fr.anyVec().makeCon(0);
      fr.add(TargetEncoder.DENOMINATOR_COL_NAME, emptyDenominator);
      
      Frame joined = BroadcastJoinForTargetEncoder.join(fr, new int[]{0}, 1, rightFr, new int[]{0}, 1);

      Scope.enter();
      assertStringVecEquals(cvec("a", "c", "b"), joined.vec("ColA"));
      assertEquals(22, joined.vec(TargetEncoder.NUMERATOR_COL_NAME).at(0), 1e-5);
      assertEquals(42, joined.vec(TargetEncoder.NUMERATOR_COL_NAME).at(1), 1e-5);
      assertEquals(44, joined.vec(TargetEncoder.DENOMINATOR_COL_NAME).at(0), 1e-5);
      assertEquals(84, joined.vec(TargetEncoder.DENOMINATOR_COL_NAME).at(1), 1e-5);
      assertTrue(joined.vec(TargetEncoder.NUMERATOR_COL_NAME).isNA(2));
      assertTrue(joined.vec(TargetEncoder.DENOMINATOR_COL_NAME).isNA(2));
      Scope.exit();
    } finally {
      if(rightFr != null) rightFr.delete();
    }
  }
  

  @Property(trials = 1000)
  public void hashCodeTest(String randomString, @InRange(minInt = 0, maxInt = 100)int randomInt) {
    String levelValue = randomString.length() == 0 ? "a" : randomString.substring(0,1);
    CompositeLookupKey lookupKey = new CompositeLookupKey(levelValue, randomInt);
    int expected = lookupKey.hashCode();
    CompositeLookupKey lookupKey2 = new CompositeLookupKey(levelValue, randomInt);
    int actual = lookupKey2.hashCode();
    assertEquals(expected, actual);
    
    //Mutation of the fields will change hash code
    lookupKey2.update("test", -1);
    assertNotEquals(lookupKey2.hashCode(), actual);
  }

  @Test
  public void serializationTest() {
    AutoBuffer ab = new AutoBuffer();
    FrameWithEncodingDataToHashMap task = new FrameWithEncodingDataToHashMap(0, -1, 1, 2);
    // After adding data to the map we should be able to serialize it
    task._encodingDataMapPerNode.put(new CompositeLookupKey("a", 42), new EncodingData(33, 55));
    task.write(ab);

    // Expectation of this test is that no exceptions will be thrown during serialisation
  }
  
  @Test
  public void icedHashMapPutAllTest() {

    IcedHashMap<CompositeLookupKey, EncodingData> mapOne = new IcedHashMap<>();
    IcedHashMap<CompositeLookupKey, EncodingData> mapTwo = new IcedHashMap<>();

    CompositeLookupKey keyOne = new CompositeLookupKey("a", 0);
    EncodingData valueOne = new EncodingData(11, 22);
    mapOne.put(keyOne, valueOne);
    
    CompositeLookupKey keyTwo = new CompositeLookupKey("b", 0);
    EncodingData valueTwo = new EncodingData(11, 33);
    mapTwo.put(keyTwo, valueTwo);

    IcedHashMap<CompositeLookupKey, EncodingData> finalMap = new IcedHashMap<>();
    
    finalMap.putAll(mapOne);
    finalMap.putAll(mapTwo);
    
    assertTrue(finalMap.containsKey(keyOne) && finalMap.containsKey(keyTwo));
    assertEquals(finalMap.get(keyOne) , valueOne);
    assertEquals(finalMap.get(keyTwo) , valueTwo);
  }

  // Shows that with Merge.merge method we will loose original order due to grouping otherwise this(swapping left and right frames) would be a possible workaround 
  @Test(expected = AssertionError.class)
  public void mergeWillUseRightFramesOrderAndGroupByValues() {
    Scope.enter();
    Frame res = null;
    try {
      Frame fr = new TestFrameBuilder()
              .withName("leftFrame")
              .withColNames("ColA", "ColB")
              .withVecTypes(Vec.T_CAT, Vec.T_NUM)
              .withDataForCol(0, ar("a", "b", "c", "e", "a"))
              .withDataForCol(1, ard(-1, 2, 3, 4, 7))
              .build();

      Frame holdoutEncodingMap = new TestFrameBuilder()
              .withName("holdoutEncodingMap")
              .withColNames("ColB", "ColC")
              .withVecTypes(Vec.T_CAT, Vec.T_NUM)
              .withDataForCol(0, ar("c", "a", "e", "b"))
              .withDataForCol(1, ard(2, 3, 4, 5))
              .build();

      //Note: we end up with the order from the `right` frame
      int[][] levelMaps = {CategoricalWrappedVec.computeMap(holdoutEncodingMap.vec(0).domain(), fr.vec(0).domain())};
      res = Merge.merge(holdoutEncodingMap, fr, new int[]{0}, new int[]{0}, false, levelMaps);
      printOutFrameAsTable(res, false, res.numRows());
      
      //We expect this assertion to fail
      assertStringVecEquals(cvec("a", "b", "c", "e", "a"), res.vec("ColB"));
    } finally {
      res.delete();
      Scope.exit();
    }
  }


  @Test(expected = DistributedException.class)
  public void foldValuesThatAreBiggerThanIntegerWillCauseExceptionTest() {
    long biggerThanIntMax = Integer.MAX_VALUE + 1;
    fr = new TestFrameBuilder()
            .withName("testFrame")
            .withColNames("ColA", "fold", TargetEncoder.NUMERATOR_COL_NAME, TargetEncoder.DENOMINATOR_COL_NAME)
            .withVecTypes(Vec.T_CAT, Vec.T_NUM, Vec.T_NUM, Vec.T_NUM)
            .withDataForCol(0, ar("a", "b", "c"))
            .withDataForCol(1, ar(biggerThanIntMax, 33, 42))
            .withDataForCol(2, ar(44, 66, 84))
            .withDataForCol(3, ar(88, 132, 168))
            .withChunkLayout(2,1)
            .build();

    IcedHashMap<CompositeLookupKey, EncodingData> encodingDataMap = new FrameWithEncodingDataToHashMap(0, 1, 2, 3)
            .doAll(fr)
            .getEncodingDataMap();
  }

  @Property(trials = 100)
  public void foldValuesThatAreInRangeWouldNotCauseExceptionTest(@InRange(minInt = 0)int randomInt) {
    fr = new TestFrameBuilder()
            .withName("testFrame")
            .withColNames("ColA", "fold", TargetEncoder.NUMERATOR_COL_NAME, TargetEncoder.DENOMINATOR_COL_NAME)
            .withVecTypes(Vec.T_CAT, Vec.T_NUM, Vec.T_NUM, Vec.T_NUM)
            .withDataForCol(0, ar("a", "b", "c"))
            .withDataForCol(1, ar(randomInt, 33, 42))
            .withDataForCol(2, ar(44, 66, 84))
            .withDataForCol(3, ar(88, 132, 168))
            .withChunkLayout(2,1)
            .build();
    
    new FrameWithEncodingDataToHashMap(0, 1, 2, 3)
            .doAll(fr)
            .getEncodingDataMap();
  }
    
  @After
  public void afterEach() {
    if (fr != null) fr.delete();
  }

}
